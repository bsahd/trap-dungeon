{
  "version": 3,
  "sources": ["../../.cache/deno/npm/registry.npmjs.org/preact/10.27.1/src/constants.js", "../../.cache/deno/npm/registry.npmjs.org/preact/10.27.1/src/util.js", "../../.cache/deno/npm/registry.npmjs.org/preact/10.27.1/src/options.js", "../../.cache/deno/npm/registry.npmjs.org/preact/10.27.1/src/create-element.js", "../../.cache/deno/npm/registry.npmjs.org/preact/10.27.1/src/component.js", "../../.cache/deno/npm/registry.npmjs.org/preact/10.27.1/src/diff/props.js", "../../.cache/deno/npm/registry.npmjs.org/preact/10.27.1/src/create-context.js", "../../.cache/deno/npm/registry.npmjs.org/preact/10.27.1/src/diff/children.js", "../../.cache/deno/npm/registry.npmjs.org/preact/10.27.1/src/diff/index.js", "../../.cache/deno/npm/registry.npmjs.org/preact/10.27.1/src/render.js", "../../.cache/deno/npm/registry.npmjs.org/preact/10.27.1/src/clone-element.js", "../../.cache/deno/npm/registry.npmjs.org/preact/10.27.1/src/diff/catch-error.js", "utils.ts", "items.ts", "game.ts", "ui_text.ts", "preact_io.tsx", "preact_main.tsx"],
  "sourcesContent": ["/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 2;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 1;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nexport const NULL = null;\nexport const UNDEFINED = undefined;\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {import('./index').ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tif (node && node.parentNode) node.parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n", "import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n", "import { slice } from './util';\nimport options from './options';\nimport { NULL, UNDEFINED } from './constants';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != NULL) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === UNDEFINED) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, NULL);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {import('./internal').VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: NULL,\n\t\t_parent: NULL,\n\t\t_depth: 0,\n\t\t_dom: NULL,\n\t\t_component: NULL,\n\t\tconstructor: UNDEFINED,\n\t\t_original: original == NULL ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == NULL && options.vnode != NULL) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: NULL };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != NULL && vnode.constructor == UNDEFINED;\n", "import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE, NULL } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != NULL && this._nextState != this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == NULL) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](https://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == NULL) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: NULL;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != NULL && sibling._dom != NULL) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : NULL;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.namespaceURI,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : NULL,\n\t\t\tcommitQueue,\n\t\t\toldDom == NULL ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != NULL && vnode._component != NULL) {\n\t\tvnode._dom = vnode._component.base = NULL;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != NULL && child._dom != NULL) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce != options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {import('./internal').Component} a\n * @param {import('./internal').Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c,\n\t\tl = 1;\n\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile (rerenderQueue.length) {\n\t\t// Keep the rerender queue sorted by (depth, insertion order). The queue\n\t\t// will initially be sorted on the first iteration only if it has more than 1 item.\n\t\t//\n\t\t// New items can be added to the queue e.g. when rerendering a provider, so we want to\n\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t// single pass\n\t\tif (rerenderQueue.length > l) {\n\t\t\trerenderQueue.sort(depthSort);\n\t\t}\n\n\t\tc = rerenderQueue.shift();\n\t\tl = rerenderQueue.length;\n\n\t\tif (c._dirty) {\n\t\t\trenderComponent(c);\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n", "import { IS_NON_DIMENSIONAL, NULL, SVG_NAMESPACE } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] == '-') {\n\t\tstyle.setProperty(key, value == NULL ? '' : value);\n\t} else if (value == NULL) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\nconst CAPTURE_REGEX = /(PointerCapture)$|Capture$/i;\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, namespace) {\n\tlet useCapture;\n\n\to: if (name == 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] != oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] == 'o' && name[1] == 'n') {\n\t\tuseCapture = name != (name = name.replace(CAPTURE_REGEX, '$1'));\n\t\tconst lowerCaseName = name.toLowerCase();\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (lowerCaseName in dom || name == 'onFocusOut' || name == 'onFocusIn')\n\t\t\tname = lowerCaseName.slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n\t\t\t\t\tname,\n\t\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\t\tuseCapture\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (namespace == SVG_NAMESPACE) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname != 'popover' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == NULL ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != NULL && (value !== false || name[4] == '-')) {\n\t\t\tdom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {import('../internal').PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == NULL) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n", "import { enqueueRender } from './component';\nimport { NULL } from './constants';\n\nexport let i = 0;\n\nexport function createContext(defaultValue) {\n\tfunction Context(props) {\n\t\tif (!this.getChildContext) {\n\t\t\t/** @type {Set<import('./internal').Component> | null} */\n\t\t\tlet subs = new Set();\n\t\t\tlet ctx = {};\n\t\t\tctx[Context._id] = this;\n\n\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\tsubs = NULL;\n\t\t\t};\n\n\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t// @ts-expect-error even\n\t\t\t\tif (this.props.value != _props.value) {\n\t\t\t\t\tsubs.forEach(c => {\n\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.sub = c => {\n\t\t\t\tsubs.add(c);\n\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\tif (subs) {\n\t\t\t\t\t\tsubs.delete(c);\n\t\t\t\t\t}\n\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\treturn props.children;\n\t}\n\n\tContext._id = '__cC' + i++;\n\tContext._defaultValue = defaultValue;\n\n\t/** @type {import('./internal').FunctionComponent} */\n\tContext.Consumer = (props, contextValue) => {\n\t\treturn props.children(contextValue);\n\t};\n\n\t// we could also get rid of _contextRef entirely\n\tContext.Provider =\n\t\tContext._contextRef =\n\t\tContext.Consumer.contextType =\n\t\t\tContext;\n\n\treturn Context;\n}\n", "import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport {\n\tEMPTY_OBJ,\n\tEMPTY_ARR,\n\tINSERT_VNODE,\n\tMATCHED,\n\tUNDEFINED,\n\tNULL\n} from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\toldDom = constructNewChildrenArray(\n\t\tnewParentVNode,\n\t\trenderResult,\n\t\toldChildren,\n\t\toldDom,\n\t\tnewChildrenLength\n\t);\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (childVNode == NULL) continue;\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index == -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tlet result = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, NULL, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == NULL && newDom != NULL) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tlet shouldPlace = !!(childVNode._flags & INSERT_VNODE);\n\t\tif (shouldPlace || oldVNode._children === childVNode._children) {\n\t\t\toldDom = insert(childVNode, oldDom, parentDom, shouldPlace);\n\t\t} else if (typeof childVNode.type == 'function' && result !== UNDEFINED) {\n\t\t\toldDom = result;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(\n\tnewParentVNode,\n\trenderResult,\n\toldChildren,\n\toldDom,\n\tnewChildrenLength\n) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = new Array(newChildrenLength);\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == NULL ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tnewParentVNode._children[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tNULL,\n\t\t\t\tchildVNode,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (childVNode.constructor == UNDEFINED && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : NULL,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tconst matchingIndex = (childVNode._index = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t));\n\n\t\toldVNode = NULL;\n\t\tif (matchingIndex != -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original == null\n\t\tconst isMounting = oldVNode == NULL || oldVNode._original == NULL;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\t// When the array of children is growing we need to decrease the skew\n\t\t\t\t// as we are adding a new element to the array.\n\t\t\t\t// Example:\n\t\t\t\t// [1, 2, 3] --> [0, 1, 2, 3]\n\t\t\t\t// oldChildren   newChildren\n\t\t\t\t//\n\t\t\t\t// The new element is at index 0, so our skew is 0,\n\t\t\t\t// we need to decrease the skew as we are adding a new element.\n\t\t\t\t// The decrease will cause us to compare the element at position 1\n\t\t\t\t// with value 1 with the element at position 0 with value 0.\n\t\t\t\t//\n\t\t\t\t// A linear concept is applied when the array is shrinking,\n\t\t\t\t// if the length is unchanged we can assume that no skew\n\t\t\t\t// changes are needed.\n\t\t\t\tif (newChildrenLength > oldChildrenLength) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else if (newChildrenLength < oldChildrenLength) {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex != skewedIndex) {\n\t\t\t// When we move elements around i.e. [0, 1, 2] --> [1, 0, 2]\n\t\t\t// --> we diff 1, we find it at position 1 while our skewed index is 0 and our skew is 0\n\t\t\t//     we set the skew to 1 as we found an offset.\n\t\t\t// --> we diff 0, we find it at position 0 while our skewed index is at 2 and our skew is 1\n\t\t\t//     this makes us increase the skew again.\n\t\t\t// --> we diff 2, we find it at position 2 while our skewed index is at 4 and our skew is 2\n\t\t\t//\n\t\t\t// this becomes an optimization question where currently we see a 1 element offset as an insertion\n\t\t\t// or deletion i.e. we optimize for [0, 1, 2] --> [9, 0, 1, 2]\n\t\t\t// while a more than 1 offset we see as a swap.\n\t\t\t// We could probably build heuristics for having an optimized course of action here as well, but\n\t\t\t// might go at the cost of some bytes.\n\t\t\t//\n\t\t\t// If we wanted to optimize for i.e. only swaps we'd just do the last two code-branches and have\n\t\t\t// only the first item be a re-scouting and all the others fall in their skewed counter-part.\n\t\t\t// We could also further optimize for swaps\n\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\tskew--;\n\t\t\t} else if (matchingIndex == skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else {\n\t\t\t\tif (matchingIndex > skewedIndex) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\n\t\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t\t// match the new skew index (i + new skew)\n\t\t\t\t// In the former two branches we know that it matches after skewing\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != NULL && (oldVNode._flags & MATCHED) == 0) {\n\t\t\t\tif (oldVNode._dom == oldDom) {\n\t\t\t\t\toldDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @param {boolean} shouldPlace\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom, shouldPlace) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom, shouldPlace);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tif (shouldPlace) {\n\t\t\tif (oldDom && parentVNode.type && !oldDom.parentNode) {\n\t\t\t\toldDom = getDomSibling(parentVNode);\n\t\t\t}\n\t\t\tparentDom.insertBefore(parentVNode._dom, oldDom || NULL);\n\t\t}\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != NULL && oldDom.nodeType == 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == NULL || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet oldVNode = oldChildren[skewedIndex];\n\tconst matched = oldVNode != NULL && (oldVNode._flags & MATCHED) == 0;\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\t//\n\t// If there is an unkeyed functional VNode, that isn't a built-in like our Fragment,\n\t// we should not search as we risk re-using state of an unrelated VNode. (reverted for now)\n\tlet shouldSearch =\n\t\t// (typeof type != 'function' || type === Fragment || key) &&\n\t\tremainingOldChildren > (matched ? 1 : 0);\n\n\tif (\n\t\t(oldVNode === NULL && childVNode.key == null) ||\n\t\t(matched && key == oldVNode.key && type == oldVNode.type)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\tlet x = skewedIndex - 1;\n\t\tlet y = skewedIndex + 1;\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tconst childIndex = x >= 0 ? x-- : y++;\n\t\t\toldVNode = oldChildren[childIndex];\n\t\t\tif (\n\t\t\t\toldVNode != NULL &&\n\t\t\t\t(oldVNode._flags & MATCHED) == 0 &&\n\t\t\t\tkey == oldVNode.key &&\n\t\t\t\ttype == oldVNode.type\n\t\t\t) {\n\t\t\t\treturn childIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n", "import {\n\tEMPTY_OBJ,\n\tMATH_NAMESPACE,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tNULL,\n\tRESET_MODE,\n\tSVG_NAMESPACE,\n\tUNDEFINED,\n\tXHTML_NAMESPACE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * @template {any} T\n * @typedef {import('../internal').Ref<T>} Ref<T>\n */\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor != UNDEFINED) return NULL;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\t\t\tconst isClassComponent =\n\t\t\t\t'prototype' in newType && newType.prototype.render;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif (isClassComponent) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (isClassComponent && c._nextState == NULL) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (isClassComponent && newType.getDerivedStateFromProps != NULL) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tc.componentWillMount != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidMount != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != NULL &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original == oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original != oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.some(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != NULL) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidUpdate != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif (isClassComponent) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != NULL) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != NULL) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != NULL && tmp.type === Fragment && tmp.key == NULL;\n\t\t\tlet renderResult = tmp;\n\n\t\t\tif (isTopLevelFragment) {\n\t\t\t\trenderResult = cloneNode(tmp.props.children);\n\t\t\t}\n\n\t\t\toldDom = diffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnamespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = NULL;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = NULL;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != NULL) {\n\t\t\t\tif (e.then) {\n\t\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t\t: MODE_SUSPENDED;\n\n\t\t\t\t\twhile (oldDom && oldDom.nodeType == 8 && oldDom.nextSibling) {\n\t\t\t\t\t\toldDom = oldDom.nextSibling;\n\t\t\t\t\t}\n\n\t\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = NULL;\n\t\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = excessDomChildren.length; i--; ) {\n\t\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t\t}\n\t\t\t\t\tmarkAsForce(newVNode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\tif (!e.then) markAsForce(newVNode);\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == NULL &&\n\t\tnewVNode._original == oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\toldDom = newVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n\n\treturn newVNode._flags & MODE_SUSPENDED ? undefined : oldDom;\n}\n\nfunction markAsForce(vnode) {\n\tif (vnode && vnode._component) vnode._component._force = true;\n\tif (vnode && vnode._children) vnode._children.forEach(markAsForce);\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\nfunction cloneNode(node) {\n\tif (\n\t\ttypeof node != 'object' ||\n\t\tnode == NULL ||\n\t\t(node._depth && node._depth > 0)\n\t) {\n\t\treturn node;\n\t}\n\n\tif (isArray(node)) {\n\t\treturn node.map(cloneNode);\n\t}\n\n\treturn assign({}, node);\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting namespaces when descending through the tree.\n\tif (nodeType == 'svg') namespace = SVG_NAMESPACE;\n\telse if (nodeType == 'math') namespace = MATH_NAMESPACE;\n\telse if (!namespace) namespace = XHTML_NAMESPACE;\n\n\tif (excessDomChildren != NULL) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value == !!nodeType &&\n\t\t\t\t(nodeType ? value.localName == nodeType : value.nodeType == 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == NULL) {\n\t\tif (nodeType == NULL) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = document.createElementNS(\n\t\t\tnamespace,\n\t\t\tnodeType,\n\t\t\tnewProps.is && newProps\n\t\t);\n\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tif (isHydrating) {\n\t\t\tif (options._hydrationMismatch)\n\t\t\t\toptions._hydrationMismatch(newVNode, excessDomChildren);\n\t\t\tisHydrating = false;\n\t\t}\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = NULL;\n\t}\n\n\tif (nodeType == NULL) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data != newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != NULL) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (!(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, NULL, value, namespace);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html != oldHtml.__html && newHtml.__html != dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\t// @ts-expect-error\n\t\t\t\tnewVNode.type == 'template' ? dom.content : dom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnodeType == 'foreignObject' ? XHTML_NAMESPACE : namespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != NULL) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (nodeType == 'progress' && inputValue == NULL) {\n\t\t\t\tdom.removeAttribute('value');\n\t\t\t} else if (\n\t\t\t\tinputValue != UNDEFINED &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType == 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType == 'option' && inputValue != oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], namespace);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked != UNDEFINED && checked != dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any> & { _unmount?: unknown }} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') {\n\t\t\tlet hasRefUnmount = typeof ref._unmount == 'function';\n\t\t\tif (hasRefUnmount) {\n\t\t\t\t// @ts-ignore TS doesn't like moving narrowing checks into variables\n\t\t\t\tref._unmount();\n\t\t\t}\n\n\t\t\tif (!hasRefUnmount || value != NULL) {\n\t\t\t\t// Store the cleanup function on the function\n\t\t\t\t// instance object itself to avoid shape\n\t\t\t\t// transitioning vnode\n\t\t\t\tref._unmount = ref(value);\n\t\t\t}\n\t\t} else ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current == vnode._dom) {\n\t\t\tapplyRef(r, NULL, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != NULL) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = NULL;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\tvnode._component = vnode._parent = vnode._dom = UNDEFINED;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n", "import { EMPTY_OBJ, NULL } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to render into\n * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\t// https://github.com/preactjs/preact/issues/3794\n\tif (parentDom == document) {\n\t\tparentDom = document.documentElement;\n\t}\n\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? NULL\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, NULL, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.namespaceURI,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t\t? NULL\n\t\t\t\t: parentDom.firstChild\n\t\t\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t\t\t: NULL,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t\t? oldVNode._dom\n\t\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n", "import { assign, slice } from './util';\nimport { createVNode } from './create-element';\nimport { NULL, UNDEFINED } from './constants';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] === UNDEFINED && defaultProps != UNDEFINED) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tNULL\n\t);\n}\n", "import { NULL } from '../constants';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {import('../internal').VNode} [oldVNode]\n * @param {import('../internal').ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {import('../internal').Component} */\n\tlet component,\n\t\t/** @type {import('../internal').ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != NULL) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != NULL) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n", "import { Cell } from \"./interfaces.ts\";\n\nexport function getLineCells(r0: number, c0: number, r1: number, c1: number) {\n  const cells = [];\n  const dc = Math.abs(c1 - c0);\n  const dr = -Math.abs(r1 - r0);\n  const sc = c0 < c1 ? 1 : -1;\n  const sr = r0 < r1 ? 1 : -1;\n  let err = dc + dr;\n\n  while (true) {\n    cells.push({ r: r0, c: c0 });\n    if (r0 === r1 && c0 === c1) break;\n    const e2 = 2 * err;\n    if (e2 >= dr) {\n      err += dr;\n      c0 += sc;\n    }\n    if (e2 <= dc) {\n      err += dc;\n      r0 += sr;\n    }\n  }\n  return cells;\n}\n\nexport function isValidCell(r: number, c: number, rows: number, cols: number) {\n  return r >= 0 && r < rows && c >= 0 && c < cols;\n}\n\nexport function getEightDirectionsNeighbors(\n  r: number,\n  c: number,\n  rows: number,\n  cols: number,\n) {\n  const neighbors = [];\n  for (let i = -1; i <= 1; i++) {\n    for (let j = -1; j <= 1; j++) {\n      if (i === 0 && j === 0) continue;\n      const nR = r + i;\n      const nC = c + j;\n      if (isValidCell(nR, nC, rows, cols)) {\n        neighbors.push({ r: nR, c: nC });\n      }\n    }\n  }\n  return neighbors;\n}\n\nexport function forEachCell<T>(\n  grid: T[][],\n  callback: (a: T, b: number, c: number) => void,\n) {\n  const rows = grid.length;\n  if (rows === 0) return;\n  const cols = grid[0].length;\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      callback(grid[r][c], r, c);\n    }\n  }\n}\n\nexport function isSolvable(\n  grid: Cell[][],\n  startR: number,\n  startC: number,\n  endR: number,\n  endC: number,\n) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));\n  const queue = [{ r: startR, c: startC }];\n\n  if (!isValidCell(startR, startC, rows, cols) || grid[startR][startC].isTrap) {\n    return false;\n  }\n  if (!isValidCell(endR, endC, rows, cols) || grid[endR][endC].isTrap) {\n    return false;\n  }\n\n  visited[startR][startC] = true;\n\n  const dr = [-1, 1, 0, 0]; // 上下左右\n  const dc = [0, 0, -1, 1];\n\n  while (queue.length > 0) {\n    const { r, c } = queue.shift() as { r: number; c: number };\n\n    if (r === endR && c === endC) {\n      return true;\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const nr = r + dr[i];\n      const nc = c + dc[i];\n\n      if (\n        isValidCell(nr, nc, rows, cols) && !visited[nr][nc] &&\n        !grid[nr][nc].isTrap\n      ) {\n        visited[nr][nc] = true;\n        queue.push({ r: nr, c: nc });\n      }\n    }\n  }\n  return false;\n}\n\nexport function isGoalInitiallyVisible(\n  grid: Cell[][],\n  startR: number,\n  startC: number,\n  exitR: number,\n  exitC: number,\n) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));\n  const queue = [{ r: startR, c: startC }];\n\n  if (startR === exitR && startC === exitC) return true; // Player starts on exit\n\n  visited[startR][startC] = true;\n\n  const dr = [-1, -1, -1, 0, 0, 1, 1, 1]; // 8 directions\n  const dc = [-1, 0, 1, -1, 1, -1, 0, 1];\n\n  while (queue.length > 0) {\n    const { r, c } = queue.shift() as { r: number; c: number };\n\n    const neighbors = getEightDirectionsNeighbors(r, c, rows, cols);\n    if (neighbors.some((n) => n.r === exitR && n.c === exitC)) {\n      return true; // Exit is visible!\n    }\n\n    if (grid[r][c].adjacentTraps > 0 && !(r === startR && c === startC)) {\n      continue;\n    }\n\n    for (let i = 0; i < 8; i++) { // Check all 8 neighbors for cascade\n      const nr = r + dr[i];\n      const nc = c + dc[i];\n\n      if (\n        isValidCell(nr, nc, rows, cols) && !visited[nr][nc] &&\n        !grid[nr][nc].isTrap\n      ) {\n        visited[nr][nc] = true;\n        queue.push({ r: nr, c: nc });\n      }\n    }\n  }\n  return false; // Exit is not visible\n}\n", "import {\n  forEachCell,\n  getEightDirectionsNeighbors,\n  getLineCells,\n  isValidCell,\n} from \"./utils.ts\";\nimport { Cell, Items } from \"./interfaces.ts\";\n\nexport const ITEMS: Items = {\n  // 通常アイテム (F1+)\n  reveal_one_trap: {\n    name: { ja: \"千里眼の巻物\", en: \"Scroll of Clairvoyance\" },\n    description: {\n      ja: \"プレイヤーの周囲8マスにある罠をすべて明らかにする。\",\n      en: \"Reveals all traps within 8 squares of the player.\",\n    },\n    key: \"r\",\n    minFloor: 1,\n    maxFloor: Infinity,\n    use: function (game) {\n      const neighborsToReveal = getEightDirectionsNeighbors(\n        game.player.r,\n        game.player.c,\n        game.rows,\n        game.cols,\n      );\n      for (const neighbor of neighborsToReveal) {\n        const cell = game.grid[neighbor.r][neighbor.c];\n        if (cell.isTrap) {\n          cell.isRevealed = true;\n          cell.isFlagged = true; // Mark revealed trap\n        } else {\n          if (\"revealFrom\" in game) {\n            game.revealFrom(neighbor.r, neighbor.c);\n          }\n        }\n      }\n      return { consumed: true };\n    },\n  },\n  trap_shield: {\n    name: { ja: \"鉄の心臓\", en: \"Heart of Iron\" },\n    description: {\n      ja: \"罠を踏んだ時に1度だけ身代わりになる。(パッシブ)\",\n      en:\n        \"When stepping on a trap, you can become a substitute once. (Passive)\",\n    },\n    key: null,\n    minFloor: 1,\n    maxFloor: Infinity,\n  },\n  reduce_traps: {\n    name: { ja: \"解体の手引き\", en: \"Disassembly Guide\" },\n    description: {\n      ja: \"ランダムな罠1つを無効化する。\",\n      en: \"Disables one random trap.\",\n    },\n    key: \"t\",\n    minFloor: 1,\n    maxFloor: 10,\n    use: function (game) {\n      const neighborsForTrapCheck = getEightDirectionsNeighbors(\n        game.player.r,\n        game.player.c,\n        game.rows,\n        game.cols,\n      );\n      const trapsInVicinity = neighborsForTrapCheck.filter((cellPos) =>\n        game.grid[cellPos.r][cellPos.c].isTrap\n      );\n\n      if (trapsInVicinity.length > 0) {\n        const trapToDemolish =\n          trapsInVicinity[Math.floor(Math.random() * trapsInVicinity.length)];\n        const cellToClear = game.grid[trapToDemolish.r][trapToDemolish.c];\n        cellToClear.isTrap = false;\n        cellToClear.isFlagged = false; // 罠と同時にフラグも解除\n        if (\"calculateNumbers\" in game) {\n          game.calculateNumbers();\n        }\n      }\n      return { consumed: true };\n    },\n  },\n  reveal_exit: {\n    name: { ja: \"出口の地図\", en: \"Map of Exit\" },\n    description: {\n      ja: \"現在のフロアの出口(E)の位置を明らかにする。\",\n      en: \"Reveal the location of exit(E) on the current floor.\",\n    },\n    key: \"e\",\n    minFloor: 1,\n    maxFloor: 8,\n    use: function (game) {\n      if (!game.exitRevealedThisFloor) {\n        game.exitRevealedThisFloor = true;\n        return { consumed: true };\n      }\n      return {\n        consumed: false,\n        message: {\n          ja: \"出口はすでに判明している。\",\n          en: \"The exit is already revealed.\",\n        },\n      };\n    },\n  },\n  long_jump: {\n    name: { ja: \"跳躍のブーツ\", en: \"Jumping Boots\" },\n    description: {\n      ja: \"指定した方向に1マス飛び越えて、2マス先に進む。\",\n      en:\n        \"Jump one square in the specified direction and move two squares forward.\",\n    },\n    key: \"j\",\n    minFloor: 1,\n    maxFloor: Infinity,\n    use: function (game) {\n      game.gameState = \"jumping_direction\";\n      return { consumed: false };\n    },\n  },\n  // 拡張アイテム (F5+)\n  recon_drone: {\n    name: { ja: \"偵察ドローン\", en: \"Reconnaissance Drone\" },\n    description: {\n      ja:\n        \"使用時、上下左右のいずれかの方向を指定する。ドローンがその方向へ一直線に飛び、通路（数字が書かれたマス）を次々と開示していく。もし進路上に罠があった場合、その罠を開示して停止する。\",\n      en:\n        \"When used, you can choose a direction: up, down, left, or right. The drone will fly in a straight line in that direction, revealing passages (squares with numbers written on them) one after another. If there is a trap in its path, it will reveal the trap and stop.\",\n    },\n    key: \"c\",\n    minFloor: 5,\n    maxFloor: Infinity,\n    use: function (game) {\n      game.gameState = \"recon_direction\";\n      return { consumed: false };\n    },\n  },\n  ariadnes_thread: {\n    name: { ja: \"アリアドネの糸\", en: \"Ariadne's Thread\" },\n    description: {\n      ja:\n        \"使用すると、プレイヤーから出口までの「最短経路」がマップ上に示される。経路上のマスはすべて開示されるが、そこにある罠もすべて表示される。\",\n      en:\n        'When used, the \"shortest path\" from the player to the exit is displayed on the map, revealing all squares along the path, including any traps.',\n    },\n    key: \"g\",\n    minFloor: 5,\n    maxFloor: Infinity,\n    use: function (game) {\n      const path = getLineCells(\n        game.player.r,\n        game.player.c,\n        game.exit.r,\n        game.exit.c,\n      );\n      if (path && path.length > 0) {\n        path.forEach((pos) => {\n          const cell = game.grid[pos.r][pos.c];\n          cell.isRevealed = true;\n          if (cell.isTrap) {\n            cell.isFlagged = true; // Mark revealed trap\n          } else {\n            cell.isFlagged = false;\n          }\n        });\n      }\n      return { consumed: true };\n    },\n  },\n  detailed_map_of_exit: {\n    name: { ja: \"詳細な出口の地図\", en: \"Detailed exit map\" },\n    description: {\n      ja:\n        \"出口の位置を明らかにすると同時に、出口に隣接する周囲8マスの状態もすべて開示する。\",\n      en:\n        \"When revealing the location of the exit, the state of all eight squares surrounding the exit is also revealed.\",\n    },\n    key: \"x\",\n    minFloor: 5,\n    maxFloor: Infinity,\n    use: function (game) {\n      const cellsToReveal = getEightDirectionsNeighbors(\n        game.exit.r,\n        game.exit.c,\n        game.rows,\n        game.cols,\n      );\n      cellsToReveal.push({ r: game.exit.r, c: game.exit.c });\n\n      // これから開示しようとするマスの中に、まだ開示されていないマスがあるかチェック\n      const hasUnrevealedCell = cellsToReveal.some((pos) =>\n        isValidCell(pos.r, pos.c, game.rows, game.cols) &&\n        !game.grid[pos.r][pos.c].isRevealed\n      );\n\n      if (hasUnrevealedCell) {\n        game.exitRevealedThisFloor = true; // 出口の位置は判明済みにする\n        for (const pos of cellsToReveal) {\n          // revealFromは内部でisRevealedチェックをするので、そのまま呼んでもOK\n          //念のためisValidCellも実行\n          if (\n            isValidCell(pos.r, pos.c, game.rows, game.cols) &&\n            \"revealFrom\" in game\n          ) {\n            game.revealFrom(pos.r, pos.c);\n          }\n        }\n        return { consumed: true };\n      } else {\n        // 開示する新しいマスが何もない場合\n        return {\n          consumed: false,\n          message: {\n            ja: \"出口の周囲はすべて判明している。\",\n            en: \"The entire area surrounding the exit is revealed.\",\n          },\n        };\n      }\n    },\n  },\n  // 上位アイテム (F10+)\n  philosophers_stone: {\n    name: { ja: \"賢者の石\", en: \"Philosopher's Stone\" },\n    description: {\n      ja: \"使用すると、プレイヤーの周囲5x5の広大な範囲を一度に開示する。\",\n      en: \"When used, it reveals a vast 5x5 area around the player at once.\",\n    },\n    key: \"p\",\n    minFloor: 10,\n    maxFloor: Infinity,\n    use: function (game) {\n      for (let i = -2; i <= 2; i++) {\n        for (let j = -2; j <= 2; j++) {\n          const nR = game.player.r + i;\n          const nC = game.player.c + j;\n          if (\n            isValidCell(nR, nC, game.rows, game.cols) && \"revealFrom\" in game\n          ) {\n            game.revealFrom(nR, nC);\n          }\n        }\n      }\n      return { consumed: true };\n    },\n  },\n  scroll_of_chaos: {\n    name: { ja: \"無秩序の巻物\", en: \"Scroll of Chaos\" },\n    description: {\n      ja:\n        \"使用すると、まだ開示もフラグもされていない全てのマスで、罠の配置をシャッフル（再配置）する。罠の総数は変わらない。\",\n      en:\n        \"When used, it shuffles (rearranges) trap placements on all squares that have not yet been revealed or flagged, but the total number of traps remains the same.\",\n    },\n    key: \"k\",\n    minFloor: 10,\n    maxFloor: Infinity,\n    use: function (game) {\n      // 1. 出口とアイテムマスの隣接マスを「罠配置禁止ゾーン」として定義\n      const protectedCells: { r: number; c: number }[] = [];\n      forEachCell(game.grid, (cell, r, c) => {\n        if ((r === game.exit.r && c === game.exit.c) || cell.itemId) {\n          protectedCells.push({ r, c });\n        }\n      });\n\n      const forbiddenZones = new Set();\n      protectedCells.forEach((pos) => {\n        // 自分自身も禁止ゾーンに含める\n        forbiddenZones.add(`${pos.r},${pos.c}`);\n        // 隣接マスを禁止ゾーンに追加\n        const neighbors = getEightDirectionsNeighbors(\n          pos.r,\n          pos.c,\n          game.rows,\n          game.cols,\n        );\n        neighbors.forEach((n) => forbiddenZones.add(`${n.r},${n.c}`));\n      });\n\n      // 2. シャッフル対象のセルを決定\n      const shufflableCells: Cell[] = [];\n      let trapCountToShuffle = 0;\n      forEachCell(game.grid, (cell, r, c) => {\n        if (\n          !cell.isRevealed && !cell.isFlagged &&\n          !forbiddenZones.has(`${r},${c}`)\n        ) {\n          shufflableCells.push(cell);\n          if (cell.isTrap) {\n            trapCountToShuffle++;\n            cell.isTrap = false; // 一旦すべての罠をクリア\n          }\n        }\n      });\n\n      // 3. シャッフル実行 (Fisher-Yates shuffle)\n      for (let i = shufflableCells.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [shufflableCells[i], shufflableCells[j]] = [\n          shufflableCells[j],\n          shufflableCells[i],\n        ];\n      }\n\n      // 4. 新しい位置に罠を配置\n      for (let i = 0; i < trapCountToShuffle; i++) {\n        shufflableCells[i].isTrap = true;\n      }\n\n      // 5. 盤面を更新\n      if (\"calculateNumbers\" in game) {\n        game.calculateNumbers();\n      }\n      return { consumed: true };\n    },\n  },\n};\n", "import {\n  Cell,\n  GameI,\n  GameLoopResult,\n  Item,\n  MultilingualText,\n} from \"./interfaces.ts\";\nimport { ITEMS } from \"./items.ts\";\nimport {\n  forEachCell,\n  getEightDirectionsNeighbors,\n  isGoalInitiallyVisible,\n  isSolvable,\n  isValidCell,\n} from \"./utils.ts\";\n\nexport class Game implements GameI {\n  grid: GameI[\"grid\"] = [];\n  rows: GameI[\"rows\"] = 8;\n  cols: GameI[\"cols\"] = 8;\n  player: GameI[\"player\"] = { r: 0, c: 0, items: [] };\n  exit: GameI[\"exit\"] = { r: 0, c: 0 };\n  floorNumber: GameI[\"floorNumber\"] = 1;\n  turn: GameI[\"turn\"] = 0;\n  gameState: GameI[\"gameState\"] = \"playing\"; // playing, confirm_next_floor, choosing_item, jumping_direction, recon_direction, gameover\n  exitRevealedThisFloor: GameI[\"exitRevealedThisFloor\"] = false;\n  REVELATION_THRESHOLD = 0.5; // 開示率のしきい値 (50%)\n  uiEffect: string | null = null;\n  justAcquiredItem: GameI[\"justAcquiredItem\"] = null;\n\n  currentItemChoices: GameI[\"currentItemChoices\"] = [];\n\n  floorRevelationRates: GameI[\"floorRevelationRates\"] = [];\n  finalFloorNumber: GameI[\"finalFloorNumber\"] = 0;\n  finalItems: GameI[\"finalItems\"] = [];\n  lastActionMessage?: MultilingualText;\n  tutorialToShow: { title: string; content: string } | null = null;\n\n  resetGame() {\n    this.grid = [];\n    this.rows = 8;\n    this.cols = 8;\n    this.player = { r: 0, c: 0, items: [] };\n    this.exit = { r: 0, c: 0 };\n    this.floorNumber = 1;\n    this.turn = 0;\n    this.gameState = \"playing\";\n    this.exitRevealedThisFloor = false;\n    this.justAcquiredItem = null;\n    this.currentItemChoices = [];\n    this.floorRevelationRates = [];\n    this.finalFloorNumber = 0;\n    this.finalItems = [];\n    this.lastActionMessage = undefined;\n    this.tutorialToShow = null;\n  }\n  getAvailableItems() {\n    const currentFloor = this.floorNumber;\n    return Object.keys(ITEMS).filter((id) => {\n      const item = ITEMS[id];\n      const minFloor = item.minFloor || 1;\n      const maxFloor = item.maxFloor || Infinity;\n      return currentFloor >= minFloor && currentFloor <= maxFloor;\n    });\n  }\n\n  hasItem(itemId: string) {\n    return this.player.items.includes(itemId);\n  }\n\n  setupFloor() {\n    this.player.r = Math.floor(Math.random() * this.rows);\n    this.player.c = Math.floor(Math.random() * this.cols);\n\n    Object.assign(this, {\n      turn: 0,\n      gameState: \"playing\",\n      exitRevealedThisFloor: false,\n    });\n\n    if (this.floorNumber === 1) {\n      this.floorRevelationRates = [];\n      this.finalFloorNumber = 0;\n      this.finalItems = [];\n    }\n\n    if (this.floorNumber === 5) {\n      this.tutorialToShow = {\n        title: \"新ギミック：見通しの悪いマス\",\n        content: `このフロアから、ひび割れた「見通しの悪いマス」が登場します。\n\nこのマスに表示される数字は、そのマスの「上下左右」4方向にある罠の数のみを示しており、「斜め」方向の罠はカウントしません。\n\n開示して初めて判明するため、注意深く探索しましょう。`,\n      };\n    }\n\n    this.rows = 8 + Math.floor(this.floorNumber / 3);\n    this.cols = 8 + Math.floor(this.floorNumber / 3);\n\n    const baseTrapCount = 8 + this.floorNumber * 2;\n    const areaBasedTrapCount = Math.floor((this.rows * this.cols) * 0.15);\n    const trapCount = Math.max(baseTrapCount, areaBasedTrapCount);\n\n    if (this.floorNumber === 1) {\n      const allAvailableItemIds = this.getAvailableItems();\n      const availableItems = allAvailableItemIds.filter((id: string) =>\n        !this.player.items.includes(id)\n      );\n      if (availableItems.length > 0) {\n        const randomItemId =\n          availableItems[Math.floor(Math.random() * availableItems.length)];\n        this.player.items.push(randomItemId);\n      }\n    }\n\n    let solvable = false;\n    let goalInitiallyVisible = false;\n    let attempts = 0;\n    const MAX_ATTEMPTS = 100;\n\n    do {\n      attempts++;\n      if (attempts > MAX_ATTEMPTS) {\n        console.warn(\n          \"Failed to generate a valid grid after\",\n          MAX_ATTEMPTS,\n          \"attempts. Forcing generation.\",\n        );\n        break;\n      }\n\n      this.generateGrid();\n      this.placeTraps(trapCount);\n      this.calculateNumbers();\n\n      const validCells: { r: number; c: number }[] = [];\n      forEachCell(this.grid, (cell, r, c) => {\n        if (\n          !cell.isTrap && cell.adjacentTraps === 0 &&\n          !(r === this.player.r && c === this.player.c)\n        ) {\n          validCells.push({ r, c });\n        }\n      });\n\n      if (validCells.length < 2) {\n        solvable = false;\n        continue;\n      }\n\n      const exitIndex = Math.floor(Math.random() * validCells.length);\n      const exitPos = validCells.splice(exitIndex, 1)[0];\n      this.exit.r = exitPos.r;\n      this.exit.c = exitPos.c;\n\n      const allPlaceableAvailable = this.getAvailableItems();\n      const placeableItems = allPlaceableAvailable.filter((\n        id: string | number,\n      ) => ITEMS[id].key !== null);\n      const numberOfItemsToPlace = 2;\n\n      for (let i = 0; i < numberOfItemsToPlace; i++) {\n        if (placeableItems.length > 0 && validCells.length > 0) {\n          const validCellIndex = Math.floor(Math.random() * validCells.length);\n          const itemPos = validCells.splice(validCellIndex, 1)[0];\n          const randomItemId =\n            placeableItems[Math.floor(Math.random() * placeableItems.length)];\n          this.grid[itemPos.r][itemPos.c].itemId = randomItemId;\n        }\n      }\n\n      solvable = isSolvable(\n        this.grid,\n        this.player.r,\n        this.player.c,\n        this.exit.r,\n        this.exit.c,\n      );\n      goalInitiallyVisible = isGoalInitiallyVisible(\n        this.grid,\n        this.player.r,\n        this.player.c,\n        this.exit.r,\n        this.exit.c,\n      );\n    } while (!solvable || goalInitiallyVisible);\n\n    // --- 「見通しの悪いマス」の配置と数字の再計算 ---\n    // ループで盤面が確定した後に、ギミックを適用する\n    if (this.floorNumber >= 5) {\n      const safeCells: Cell[] = [];\n      // プレイヤーの周囲9マスは安全地帯とする\n      const playerArea = new Set();\n      const playerNeighbors = getEightDirectionsNeighbors(\n        this.player.r,\n        this.player.c,\n        this.rows,\n        this.cols,\n      );\n      playerArea.add(`${this.player.r},${this.player.c}`);\n      playerNeighbors.forEach((pos) => playerArea.add(`${pos.r},${pos.c}`));\n\n      forEachCell(this.grid, (cell, r, c) => {\n        const isExit = r === this.exit.r && c === this.exit.c;\n        // 罠でもなく、プレイヤーの周囲でもなく、アイテムマスでもなく、出口でもないマスを候補とする\n        if (\n          !cell.isTrap && !playerArea.has(`${r},${c}`) && !cell.itemId &&\n          !isExit\n        ) {\n          safeCells.push(cell);\n        }\n      });\n\n      // 安全なマスの15%を「見通しの悪いマス」にする\n      const obscureCount = Math.floor(safeCells.length * 0.15);\n      for (let i = 0; i < obscureCount; i++) {\n        if (safeCells.length === 0) break;\n        const randomIndex = Math.floor(Math.random() * safeCells.length);\n        const selectedCell = safeCells.splice(randomIndex, 1)[0];\n        selectedCell.isObscured = true;\n      }\n\n      // 「見通しの悪いマス」を適用したことで数字が変わるため、再計算する\n      this.calculateNumbers();\n    }\n\n    this.revealFrom(this.player.r, this.player.c);\n  }\n\n  generateGrid() {\n    this.grid = Array.from(\n      { length: this.rows },\n      () =>\n        Array.from({ length: this.cols }, () => ({\n          isTrap: false,\n          isRevealed: false,\n          adjacentTraps: 0,\n          isFlagged: false,\n          isObscured: false,\n        })),\n    );\n  }\n\n  placeTraps(trapCount: number) {\n    const forbiddenTrapZones = getEightDirectionsNeighbors(\n      this.player.r,\n      this.player.c,\n      this.rows,\n      this.cols,\n    );\n    forbiddenTrapZones.push({ r: this.player.r, c: this.player.c });\n\n    let trapsPlaced = 0;\n    while (trapsPlaced < trapCount) {\n      const r = Math.floor(Math.random() * this.rows);\n      const c = Math.floor(Math.random() * this.cols);\n\n      const isForbidden = forbiddenTrapZones.some((pos) =>\n        pos.r === r && pos.c === c\n      );\n      const isExit = r === this.exit.r && c === this.exit.c;\n\n      if (!this.grid[r][c].isTrap && !isExit && !isForbidden) {\n        this.grid[r][c].isTrap = true;\n        trapsPlaced++;\n      }\n    }\n  }\n\n  calculateNumbers() {\n    forEachCell(this.grid, (cell, r, c) => {\n      if (cell.isTrap) return;\n      let trapCount = 0;\n      const neighbors = getEightDirectionsNeighbors(r, c, this.rows, this.cols);\n\n      if (cell.isObscured) {\n        // 「見通しの悪いマス」は上下左右4方向のみチェック\n        const crossNeighbors = neighbors.filter((n) => n.r === r || n.c === c);\n        for (const neighbor of crossNeighbors) {\n          if (this.grid[neighbor.r][neighbor.c].isTrap) {\n            trapCount++;\n          }\n        }\n      } else {\n        // 通常のマスは8方向をチェック\n        for (const neighbor of neighbors) {\n          if (this.grid[neighbor.r][neighbor.c].isTrap) {\n            trapCount++;\n          }\n        }\n      }\n      cell.adjacentTraps = trapCount;\n    });\n  }\n\n  revealFrom(r: number, c: number) {\n    if (\n      !isValidCell(r, c, this.rows, this.cols) || this.grid[r][c].isRevealed\n    ) return;\n\n    const cell = this.grid[r][c];\n    cell.isRevealed = true;\n    cell.isFlagged = false;\n\n    // 罠のマスでは再帰しない、かつ、隣接する罠が0のマスでのみ再帰する\n    if (!cell.isTrap && cell.adjacentTraps === 0) {\n      let neighbors;\n      if (cell.isObscured) {\n        // 「見通しの悪いマス」からは4方向にのみ再帰\n        const allNeighbors = getEightDirectionsNeighbors(\n          r,\n          c,\n          this.rows,\n          this.cols,\n        );\n        neighbors = allNeighbors.filter((n) => n.r === r || n.c === c);\n      } else {\n        // 通常のマスからは8方向に再帰\n        neighbors = getEightDirectionsNeighbors(r, c, this.rows, this.cols);\n      }\n\n      for (const neighbor of neighbors) {\n        this.revealFrom(neighbor.r, neighbor.c);\n      }\n    }\n  }\n\n  toggleFlag(r: number, c: number) {\n    if (isValidCell(r, c, this.rows, this.cols)) {\n      const cell = this.grid[r][c];\n      if (!cell.isRevealed) {\n        cell.isFlagged = !cell.isFlagged;\n      }\n    }\n  }\n\n  calculateRevelationRate() {\n    let revealedCount = 0;\n    forEachCell(this.grid, (cell) => {\n      if (cell.isRevealed) {\n        revealedCount++;\n      }\n    });\n    return revealedCount / (this.rows * this.cols);\n  }\n\n  getDisplayState() {\n    return {\n      grid: this.grid,\n      player: { r: this.player.r, c: this.player.c },\n      exit: this.exit,\n      floorNumber: this.floorNumber,\n      items: this.player.items,\n      turn: this.turn,\n      gameState: this.gameState,\n      currentItemChoices: this.currentItemChoices,\n      exitRevealedThisFloor: this.exitRevealedThisFloor,\n    };\n  }\n\n  handleInput(key: string) {\n    key = key.toLowerCase();\n\n    if (this.gameState === \"confirm_next_floor\") {\n      if (key === \"yes\") {\n        const currentRevelationRate = this.calculateRevelationRate();\n        this.floorRevelationRates.push({\n          floor: this.floorNumber,\n          rate: currentRevelationRate,\n        });\n        if (currentRevelationRate < this.REVELATION_THRESHOLD) {\n          this.lastActionMessage = {\n            ja: `フロア開示率が${\n              (this.REVELATION_THRESHOLD * 100).toFixed(0)\n            }%未満のため、アイテムボーナスはありませんでした。（${\n              (currentRevelationRate * 100).toFixed(0)\n            }%)`,\n            en:\n              `There were no item bonuses as the floor disclosure rate was less than ${\n                (this.REVELATION_THRESHOLD * 100).toFixed(0)\n              }%.${(currentRevelationRate * 100).toFixed(0)}%)`,\n          };\n          this.floorNumber++;\n          this.setupFloor();\n        } else {\n          this.gameState = \"choosing_item\";\n          this.showItemChoiceScreen();\n        }\n      } else {\n        this.gameState = \"playing\";\n      }\n    } else if (this.gameState === \"choosing_item\") {\n      const selectedIndex = parseInt(key, 10) - 1;\n      if (\n        selectedIndex >= 0 && selectedIndex < this.currentItemChoices.length\n      ) {\n        const chosenId = this.currentItemChoices[selectedIndex];\n        this.player.items.push(chosenId);\n      }\n      return { action: \"next_floor_after_delay\" };\n    } else if (this.gameState === \"recon_direction\") {\n      let dr = 0, dc = 0, directionChosen = false;\n      switch (key) {\n        case \"w\":\n          dr = -1;\n          directionChosen = true;\n          break;\n        case \"a\":\n          dc = -1;\n          directionChosen = true;\n          break;\n        case \"s\":\n          dr = 1;\n          directionChosen = true;\n          break;\n        case \"d\":\n          dc = 1;\n          directionChosen = true;\n          break;\n        default:\n          this.gameState = \"playing\";\n          this.lastActionMessage = {\n            ja: \"偵察ドローンの使用をキャンセルしました。\",\n            en: \"Cancelled the use of the recon drone.\",\n          };\n          return this.gameLoop();\n      }\n      if (directionChosen) {\n        const itemIndex = this.player.items.indexOf(\"recon_drone\");\n        if (itemIndex > -1) this.player.items.splice(itemIndex, 1);\n        let r = this.player.r, c = this.player.c;\n        while (true) {\n          r += dr;\n          c += dc;\n          if (!isValidCell(r, c, this.rows, this.cols)) break;\n          const cell = this.grid[r][c];\n          if (cell.isTrap) {\n            cell.isRevealed = true;\n            cell.isFlagged = true;\n            break;\n          } else {\n            this.revealFrom(r, c);\n          }\n        }\n        this.gameState = \"playing\";\n        this.turn++;\n        this.processPlayerLocation();\n      }\n    } else if (this.gameState === \"jumping_direction\") {\n      let jumpRow = this.player.r, jumpCol = this.player.c, jumped = false;\n      switch (key) {\n        case \"w\":\n          jumpRow -= 2;\n          jumped = true;\n          break;\n        case \"a\":\n          jumpCol -= 2;\n          jumped = true;\n          break;\n        case \"s\":\n          jumpRow += 2;\n          jumped = true;\n          break;\n        case \"d\":\n          jumpCol += 2;\n          jumped = true;\n          break;\n        default:\n          this.gameState = \"playing\";\n          this.lastActionMessage = {\n            ja: \"跳躍のブーツの使用をキャンセルしました。\",\n            en: \"Cancelled use of Jumping Boots.\",\n          };\n          return this.gameLoop();\n      }\n      if (jumped && isValidCell(jumpRow, jumpCol, this.rows, this.cols)) {\n        const itemIndex = this.player.items.indexOf(\"long_jump\");\n        if (itemIndex > -1) this.player.items.splice(itemIndex, 1);\n        this.player.r = jumpRow;\n        this.player.c = jumpCol;\n        this.gameState = \"playing\";\n        this.turn++;\n        this.processPlayerLocation();\n      } else {\n        this.gameState = \"playing\";\n      }\n    } else if (this.gameState === \"playing\") {\n      let newRow = this.player.r,\n        newCol = this.player.c,\n        moved = false,\n        itemUsed = false;\n      const itemToUseId = Object.keys(ITEMS).find((id) =>\n        ITEMS[id].key === key\n      );\n      if (itemToUseId && this.hasItem(itemToUseId)) {\n        const item = ITEMS[itemToUseId];\n        if (item.use) {\n          const result = item.use(this);\n          itemUsed = true;\n          if (result.consumed) {\n            const itemIndex = this.player.items.indexOf(itemToUseId);\n            if (itemIndex > -1) this.player.items.splice(itemIndex, 1);\n          }\n          if (result.message) this.lastActionMessage = result.message;\n        }\n      } else {\n        switch (key) {\n          case \"w\":\n            newRow--;\n            moved = true;\n            break;\n          case \"a\":\n            newCol--;\n            moved = true;\n            break;\n          case \"s\":\n            newRow++;\n            moved = true;\n            break;\n          case \"d\":\n            newCol++;\n            moved = true;\n            break;\n        }\n      }\n      if (moved) {\n        if (isValidCell(newRow, newCol, this.rows, this.cols)) {\n          if (this.grid[newRow][newCol].isFlagged) {\n            this.lastActionMessage = {\n              ja: \"チェックしたマスには移動できません。\",\n              en: \"You cannot move to a checked square.\",\n            };\n            return this.gameLoop();\n          }\n          this.player.r = newRow;\n          this.player.c = newCol;\n        } else {\n          return this.gameLoop();\n        }\n      }\n      if (moved || (itemUsed && this.gameState === \"playing\")) {\n        this.turn++;\n        this.processPlayerLocation();\n      }\n    }\n    return this.gameLoop();\n  }\n\n  processPlayerLocation() {\n    const currentCell = this.grid[this.player.r][this.player.c];\n    if (this.player.r === this.exit.r && this.player.c === this.exit.c) {\n      this.gameState = \"confirm_next_floor\";\n    }\n    if (currentCell.isTrap) {\n      if (this.hasItem(\"trap_shield\")) {\n        const index = this.player.items.indexOf(\"trap_shield\");\n        this.player.items.splice(index, 1);\n        currentCell.isTrap = false;\n        this.calculateNumbers();\n        this.revealFrom(this.player.r, this.player.c);\n        this.uiEffect = \"flash_red\";\n        this.lastActionMessage = {\n          ja: \"鉄の心臓が身代わりになった！\",\n          en: \"The Iron Heart has taken its place!\",\n        };\n      } else {\n        currentCell.isRevealed = true;\n        this.gameState = \"gameover\";\n        this.lastActionMessage = {\n          ja: \"罠を踏んでしまった！\",\n          en: \"I stepped into a trap!\",\n        };\n      }\n    }\n    if (currentCell.itemId) {\n      const itemId = currentCell.itemId;\n      this.player.items.push(itemId);\n      currentCell.itemId = undefined;\n      this.justAcquiredItem = itemId;\n    }\n    if (this.gameState !== \"gameover\") {\n      this.revealFrom(this.player.r, this.player.c);\n    }\n  }\n\n  showItemChoiceScreen() {\n    const choices: string[] = [];\n    const itemIds = this.getAvailableItems();\n    while (choices.length < 3 && choices.length < itemIds.length) {\n      const randomId = itemIds[Math.floor(Math.random() * itemIds.length)];\n      if (!choices.includes(randomId)) {\n        choices.push(randomId);\n      }\n    }\n    this.currentItemChoices = choices;\n  }\n\n  gameLoop(): GameLoopResult {\n    if (this.gameState === \"gameover\") {\n      this.finalFloorNumber = this.floorNumber;\n      this.finalItems = [...this.player.items];\n      return {\n        displayState: this.getDisplayState(),\n        message: \"!!! GAME OVER !!!\",\n        gameState: \"gameover\",\n        result: {\n          floorRevelationRates: this.floorRevelationRates,\n          finalFloorNumber: this.finalFloorNumber,\n          finalItems: this.finalItems.reduce((counts, id) => {\n            counts[id] = (counts[id] || 0) + 1;\n            return counts;\n          }, {} as { [x: string]: number }),\n        },\n      };\n    }\n    let promptText = \"Move (w/a/s/d)\";\n    const itemActions = this.player.items\n      .map((id) => ITEMS[id])\n      .filter((item) => item.key)\n      .map((item) => `${item.key}: ${item.name}`);\n    if (itemActions.length > 0) {\n      promptText += ` | Use Item (${itemActions.join(\", \")})`;\n    }\n    promptText += \" > \";\n    let message = \"\";\n    if (this.gameState === \"choosing_item\") {\n      message = \"Floor Cleared! Choose your reward:\";\n    } else if (this.gameState === \"jumping_direction\") {\n      message = \"Jump direction (w/a/s/d):\";\n    } else if (this.gameState === \"recon_direction\") {\n      message = \"Recon direction (w/a/s/d):\";\n    } else if (this.gameState === \"confirm_next_floor\") {\n      message = \"Go next floor?\";\n    }\n    const result: GameLoopResult = {\n      displayState: this.getDisplayState(),\n      prompt: promptText,\n      message: message,\n      lastActionMessage: this.lastActionMessage,\n      uiEffect: this.uiEffect,\n      gameState: this.gameState,\n      newItemAcquired: null as (Item & { id: string }) | null,\n      tutorialToShow:\n        undefined as ({ title: string; content: string } | undefined),\n    };\n    if (this.justAcquiredItem) {\n      result.newItemAcquired = {\n        id: this.justAcquiredItem,\n        ...ITEMS[this.justAcquiredItem],\n      };\n    }\n    if (this.tutorialToShow) {\n      result.tutorialToShow = this.tutorialToShow;\n    }\n    return result;\n  }\n\n  clearLastActionMessage() {\n    this.lastActionMessage = undefined;\n  }\n\n  clearUiEffect() {\n    this.uiEffect = null;\n  }\n\n  clearJustAcquiredItem() {\n    this.justAcquiredItem = null;\n  }\n\n  clearTutorial() {\n    this.tutorialToShow = null;\n  }\n}\n", "export const UI_TEXT = {\n  disclosureRateAchieved: {\n    ja: \"開示率: 達成\",\n    en: \"Disclosure rate: Achieved\",\n  },\n  disclosureRateNotAchieved: {\n    ja: \"開示率: 未達成\",\n    en: \"Disclosure rate: Not Achieved\",\n  },\n  itemAcquisition: {\n    ja: \"アイテム獲得\",\n    en: \"Item Acquisition\",\n  },\n  finalFloorReached: {\n    ja: \"最終到達フロア\",\n    en: \"Final floor reached\",\n  },\n  possessedItems: {\n    ja: \"所持アイテム\",\n    en: \"Possessed items\",\n  },\n  floorDisclosureRate: {\n    ja: \"各フロアの開示率\",\n    en: \"Disclosure rate for each floor\",\n  },\n  floor: {\n    ja: \"フロア\",\n    en: \"Floor\",\n  },\n  chooseReward: {\n    ja: \"フロアをクリアしました!報酬を選択してください\",\n    en: \"Floor Cleared! Choose a reward\",\n  },\n  none: {\n    ja: \"なし\",\n    en: \"None\",\n  },\n  noUsableItem: {\n    ja: \"使用できるアイテムがありません。\",\n    en: \"No Usable Items.\",\n  },\n  useItem: {\n    ja: \"アイテムを使用する\",\n    en: \"Use Item\",\n  },\n  viewDetail: {\n    ja: (itemName: string) => itemName + \"の詳細を見る\",\n    en: (itemName: string) => \"View details of \" + itemName,\n  },\n  close: {\n    ja: \"閉じる\",\n    en: \"Close\",\n  },\n  yes: {\n    ja: \"はい\",\n    en: \"Yes\",\n  },\n  no: {\n    ja: \"いいえ\",\n    en: \"No\",\n  },\n  playAgain: {\n    ja: \"もう一度プレイする\",\n    en: \"Play Again\",\n  },\n  gameOver: {\n    ja: \"ゲームオーバー\",\n    en: \"Game Over\",\n  },\n};\n", "/// <reference lib=\"dom\" />\nimport { Game } from \"./game.ts\";\nimport { Fragment, h } from \"preact\";\nimport { useEffect, useState } from \"preact/hooks\";\nimport { DisplayState, GameI, Item } from \"./interfaces.ts\";\nimport { ITEMS } from \"./items.ts\";\nimport { UI_TEXT } from \"./ui_text.ts\";\n\nconst LANG = \"ja\";\n\nexport function GameGrid(\n  props: { displayState?: DisplayState; runGameLoop: () => void },\n) {\n  if (!props.displayState) {\n    return <></>;\n  }\n  const displayState = props.displayState;\n  return (\n    <table class=\"game-table\" style={{ \"--dynamic-cell-size\": \"32px\" }}>\n      {displayState.grid.map((row, r) => (\n        <tr key={r}>\n          {row.map((gridCell, c) => {\n            const cellClasses = [\"game-cell\"];\n\n            const isPlayer = r === displayState.player.r &&\n              c === displayState.player.c;\n            const isExit = r === displayState.exit.r &&\n              c === displayState.exit.c;\n            const isRevealed = gridCell.isRevealed ||\n              (isExit && displayState.exitRevealedThisFloor);\n\n            // 開示されていて、かつ見通しの悪いマスの場合にのみスタイルを適用\n            if (gridCell.isObscured && isRevealed) {\n              cellClasses.push(\"game-cell--obscured\");\n            }\n\n            const flagAction = (event: Event) => {\n              if (isRevealed) return;\n              event.preventDefault();\n              gameInstance.toggleFlag(r, c);\n              props.runGameLoop();\n            };\n\n            let numberContent = \"\";\n            let entityContent = \"\";\n            let playerContent = \"\";\n\n            if (isPlayer) {\n              playerContent = \"@\";\n\n              if (gridCell.isTrap) {\n                cellClasses.push(\"game-cell--trap\");\n                numberContent = \"X\";\n              } else {\n                cellClasses.push(\"game-cell--player\");\n                numberContent = gridCell.adjacentTraps === 0\n                  ? \"\"\n                  : gridCell.adjacentTraps.toString();\n              }\n              if (gridCell.itemId) entityContent = \"I\";\n              if (isExit) entityContent = \"E\";\n            } else if (isRevealed) {\n              if (isExit) {\n                cellClasses.push(\"game-cell--exit\");\n                numberContent = \"E\";\n              } else if (gridCell.itemId) {\n                cellClasses.push(\"game-cell--item\");\n                numberContent = \"I\";\n              } else if (gridCell.isTrap) {\n                cellClasses.push(\"game-cell--trap\");\n                numberContent = \"X\";\n              } else {\n                cellClasses.push(\"game-cell--revealed\");\n                numberContent = gridCell.adjacentTraps === 0\n                  ? \"\"\n                  : gridCell.adjacentTraps.toString();\n              }\n            } else if (gridCell.isFlagged) {\n              cellClasses.push(\"game-cell--flagged\");\n              numberContent = \"⚑\";\n            } else {\n              cellClasses.push(\"game-cell--hidden\");\n            }\n\n            return (\n              <td\n                class={cellClasses.join(\" \")}\n                onClick={flagAction}\n                onContextMenu={flagAction}\n                key={c}\n              >\n                <span\n                  class={\"cell-number\" +\n                    (isPlayer ? \"cell-number--player-present\" : \"\")}\n                >\n                  {numberContent}\n                </span>\n                {entityContent && (\n                  <span class=\"cell-entity\">{entityContent}</span>\n                )}\n                {playerContent && (\n                  <span class=\"cell-player-icon\">{playerContent}</span>\n                )}\n              </td>\n            );\n          })}\n        </tr>\n      ))}\n    </table>\n  );\n}\n\nconst gameInstance = new Game();\ngameInstance.setupFloor();\n\nexport function GameMain() {\n  const [displayState, setDisplayState] = useState<DisplayState>();\n  const runGameLoop = (key?: string) => {\n    if (key) {\n      const actionResult = gameInstance.handleInput(key);\n      if (\n        \"action\" in actionResult &&\n        actionResult.action === \"next_floor_after_delay\"\n      ) {\n        gameInstance.floorNumber++;\n        gameInstance.setupFloor();\n      }\n    }\n    const gameResult = gameInstance.gameLoop();\n    console.log(gameResult);\n\n    document.body.dataset.gameState = gameResult.gameState;\n\n    if (gameResult.gameState != \"gameover\" && gameResult.newItemAcquired) {\n      const item = gameResult.newItemAcquired;\n      const message = `${UI_TEXT.itemAcquisition[LANG]}: ${item.name[LANG]}`;\n      // showNotification(message, 3000);\n      alert(message);\n      gameInstance.clearJustAcquiredItem();\n    }\n\n    setDisplayState(gameResult.displayState);\n\n    const gameState = gameResult.gameState;\n\n    if (gameState === \"confirm_next_floor\") {\n      // renderConfirmDialog(gameResult.message);\n      runGameLoop(confirm(gameResult.message) ? \"yes\" : \"no\");\n    } else if (gameState === \"choosing_item\") {\n      const itemNum = parseInt(\n        prompt(gameResult.displayState.currentItemChoices.join(\"\\n\")) ?? \"\",\n      );\n    } else if (gameState === \"gameover\") {\n      alert(JSON.stringify(gameResult.result));\n    } else if (\n      [\"playing\", \"jumping_direction\", \"recon_direction\"].includes(gameState)\n    ) {\n      // setupControlButtons();\n    }\n\n    if (gameResult.gameState != \"gameover\" && gameResult.lastActionMessage) {\n      alert(gameResult.lastActionMessage[LANG]);\n      gameInstance.clearLastActionMessage();\n    }\n\n    if (\n      [\"jumping_direction\", \"recon_direction\"].includes(gameState) &&\n      gameResult.message\n    ) {\n      // dom.actionPrompt.textContent = gameResult.message;\n    }\n\n    if (\n      gameResult.message &&\n      ![\n        \"choosing_item\",\n        \"confirm_next_floor\",\n        \"jumping_direction\",\n        \"recon_direction\",\n      ].includes(gameState)\n    ) {\n      alert(gameResult.message);\n    }\n\n    if (\n      gameResult.gameState != \"gameover\" && gameResult.uiEffect === \"flash_red\"\n    ) {\n      // flashScreenRed();\n      // gameInstance.clearUiEffect();\n    }\n\n    if (gameResult.gameState != \"gameover\" && gameResult.tutorialToShow) {\n      alert(\n        gameResult.tutorialToShow.title + \"\\n\" +\n          gameResult.tutorialToShow.content,\n      );\n    }\n  };\n\n  useEffect(() => {\n    runGameLoop();\n    const handleGlobalKeyboardInput = (event: KeyboardEvent) => {\n      const modal = document.querySelector(\".modal-overlay\");\n      if (event.key === \"Escape\" && modal) {\n        modal.remove();\n        return;\n      }\n      if (modal) return;\n\n      let key = event.key.toLowerCase();\n      switch (event.key) {\n        case \"ArrowUp\":\n          key = \"w\";\n          break;\n        case \"ArrowDown\":\n          key = \"s\";\n          break;\n        case \"ArrowLeft\":\n          key = \"a\";\n          break;\n        case \"ArrowRight\":\n          key = \"d\";\n          break;\n      }\n\n      let handled = true;\n\n      if (gameInstance.gameState === \"confirm_next_floor\") {\n        // event.preventDefault();\n        // const choices = [\"yes\", \"no\"];\n        // switch (key) {\n        //   case \"w\":\n        //     selectedConfirmIndex = (selectedConfirmIndex > 0)\n        //       ? selectedConfirmIndex - 1\n        //       : choices.length - 1;\n        //     updateConfirmHighlight();\n        //     break;\n        //   case \"s\":\n        //     selectedConfirmIndex = (selectedConfirmIndex < choices.length - 1)\n        //       ? selectedConfirmIndex + 1\n        //       : 0;\n        //     updateConfirmHighlight();\n        //     break;\n        //   case \"enter\":\n        //     processBrowserInput(choices[selectedConfirmIndex]);\n        //     break;\n        //   default:\n        //     break;\n        // }\n      } else if (gameInstance.gameState === \"choosing_item\") {\n        // event.preventDefault();\n        // const choices = document.querySelectorAll(\".item-choice-btn\");\n        // if (!choices.length) return;\n\n        // if (isInputDebounced(key)) return;\n\n        // switch (key) {\n        //   case \"w\":\n        //     selectedChoiceIndex = (selectedChoiceIndex > 0)\n        //       ? selectedChoiceIndex - 1\n        //       : choices.length - 1;\n        //     updateChoiceHighlight();\n        //     break;\n        //   case \"s\":\n        //     selectedChoiceIndex = (selectedChoiceIndex < choices.length - 1)\n        //       ? selectedChoiceIndex + 1\n        //       : 0;\n        //     updateChoiceHighlight();\n        //     break;\n        //   case \"enter\":\n        //     {\n        //       const selectedButton = choices[selectedChoiceIndex];\n        //       if (selectedButton) {\n        //         (selectedButton as HTMLButtonElement).click();\n        //       }\n        //     }\n        //     break;\n        //   default:\n        //     handled = false;\n        //     break;\n        // }\n      } else if (\n        [\"jumping_direction\", \"recon_direction\"].includes(\n          gameInstance.gameState,\n        )\n      ) {\n        if (\"wasd\".includes(key)) {\n          runGameLoop(key);\n        } else {\n          handled = false;\n        }\n      } else if (gameInstance.gameState === \"playing\") {\n        const itemKeys = Object.values(ITEMS).map((item) => item.key).filter((\n          k,\n        ) => k).join(\"\");\n        const validKeys = \"wasd\" + itemKeys;\n\n        if (validKeys.includes(key)) {\n          runGameLoop(key);\n        } else {\n          handled = false;\n        }\n      } else {\n        handled = false;\n      }\n\n      if (handled) {\n        event.preventDefault();\n      }\n    };\n    document.addEventListener(\"keydown\", handleGlobalKeyboardInput);\n    return () => {\n      document.removeEventListener(\"keydown\", handleGlobalKeyboardInput);\n    };\n  }, []);\n  return (\n    <div>\n      <GameGrid displayState={displayState} runGameLoop={runGameLoop}>\n      </GameGrid>\n      <button\n        type=\"button\"\n        onClick={() => {\n          runGameLoop(\"w\");\n        }}\n      >\n        w\n      </button>\n      <button\n        type=\"button\"\n        onClick={() => {\n          runGameLoop(\"a\");\n        }}\n      >\n        a\n      </button>\n      <button\n        type=\"button\"\n        onClick={() => {\n          runGameLoop(\"s\");\n        }}\n      >\n        s\n      </button>\n      <button\n        type=\"button\"\n        onClick={() => {\n          runGameLoop(\"d\");\n        }}\n      >\n        d\n      </button>\n    </div>\n  );\n}\n", "import { h, render } from \"preact\";\nimport { GameMain } from \"./preact_io.tsx\";\n\nwindow.onload = () => {\n  document.getElementById(\"root\")!.innerHTML = \"\";\n  render(<GameMain />, document.getElementById(\"root\")!);\n};\n"],
  "mappings": "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",
  "names": ["slice", "options", "isValidElement", "rerenderQueue", "defer", "depthSort", "eventClock", "eventProxy", "i", "EMPTY_OBJ", "s", "a", "IS_NON_DIMENSIONAL", "p", "v", "y", "w", "assign", "getLineCells", "r0", "c0", "r1", "c1", "cells", "dc", "dr", "sc", "sr", "err", "e2", "isValidCell", "r", "c", "rows", "cols", "getEightDirectionsNeighbors", "neighbors", "i", "j", "nR", "nC", "forEachCell", "grid", "callback", "isSolvable", "startR", "startC", "endR", "endC", "visited", "queue", "nr", "nc", "isGoalInitiallyVisible", "exitR", "exitC", "n", "ITEMS", "game", "neighborsToReveal", "getEightDirectionsNeighbors", "neighbor", "cell", "trapsInVicinity", "cellPos", "trapToDemolish", "cellToClear", "path", "getLineCells", "pos", "cellsToReveal", "isValidCell", "i", "j", "nR", "nC", "protectedCells", "forEachCell", "r", "c", "forbiddenZones", "n", "shufflableCells", "trapCountToShuffle", "Game", "currentFloor", "ITEMS", "id", "item", "minFloor", "maxFloor", "itemId", "baseTrapCount", "areaBasedTrapCount", "trapCount", "availableItems", "randomItemId", "solvable", "goalInitiallyVisible", "attempts", "MAX_ATTEMPTS", "validCells", "forEachCell", "cell", "r", "c", "exitIndex", "exitPos", "placeableItems", "numberOfItemsToPlace", "i", "validCellIndex", "itemPos", "isSolvable", "isGoalInitiallyVisible", "safeCells", "playerArea", "playerNeighbors", "getEightDirectionsNeighbors", "pos", "isExit", "obscureCount", "randomIndex", "selectedCell", "forbiddenTrapZones", "trapsPlaced", "isForbidden", "neighbors", "crossNeighbors", "n", "neighbor", "isValidCell", "revealedCount", "key", "currentRevelationRate", "selectedIndex", "chosenId", "dr", "dc", "directionChosen", "itemIndex", "jumpRow", "jumpCol", "jumped", "newRow", "newCol", "moved", "itemUsed", "itemToUseId", "result", "currentCell", "index", "choices", "itemIds", "randomId", "counts", "promptText", "itemActions", "message", "UI_TEXT", "itemName", "LANG", "GameGrid", "props", "_", "k", "displayState", "row", "r", "gridCell", "c", "cellClasses", "isPlayer", "isExit", "isRevealed", "flagAction", "event", "gameInstance", "numberContent", "entityContent", "playerContent", "Game", "GameMain", "setDisplayState", "d", "runGameLoop", "key", "actionResult", "gameResult", "item", "message", "UI_TEXT", "gameState", "itemNum", "y", "handleGlobalKeyboardInput", "modal", "handled", "ITEMS", "G", "_", "GameMain"]
}
